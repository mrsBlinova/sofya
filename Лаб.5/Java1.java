// Шаг 1: Импортируем необходимые классы Java
import java.util.*;

// Шаг 2: Создаем основной класс TSP (Traveling Salesman Problem)
public class TSP {
    
    // Шаг 3: Основная функция для решения задачи коммивояжера
    private static int tsp(int[][] graph, int s) {
        // Шаг 4: Получаем количество вершин (городов) в графе
        int V = graph.length;
        
        // Шаг 5: Создаем список для хранения вершин, кроме стартовой
        List<Integer> vertex = new ArrayList<>();
        
        // Шаг 6: Заполняем список всеми городами, кроме стартового
        for(int i = 0; i < V; i++)
            if(i != s)
                vertex.add(i);
        
        // Шаг 7: Инициализируем минимальный путь максимально возможным значением
        int min_path = Integer.MAX_VALUE;
        
        // Шаг 8: Начинаем перебор всех возможных перестановок городов
        do {
            // Шаг 9: Инициализируем вес текущего пути
            int current_pathweight = 0;
            
            // Шаг 10: Начинаем со стартового города
            int j = s;
            
            // Шаг 11: Проходим по всем городам в текущей перестановке
            for(int i = 0; i < vertex.size(); i++) {
                // Шаг 12: Добавляем вес ребра от текущего города к следующему
                current_pathweight += graph[j][vertex.get(i)];
                
                // Шаг 13: Переходим к следующему городу
                j = vertex.get(i);
            }
            
            // Шаг 14: Добавляем вес возвращения в стартовый город
            current_pathweight += graph[j][s];
            
            // Шаг 15: Обновляем минимальный путь, если нашли лучшее решение
            min_path = Math.min(min_path, current_pathweight);
            
        } while(nextPermutation(vertex)); // Шаг 16: Генерируем следующую перестановку
        
        // Шаг 17: Возвращаем найденный минимальный путь
        return min_path;
    }
    
    // Шаг 18: Вспомогательная функция для генерации следующей перестановки
    private static boolean nextPermutation(List<Integer> list) {
        // Шаг 19: Находим самый правый индекс, где list[i] < list[i+1]
        int i = list.size() - 2;
        while (i >= 0 && list.get(i) >= list.get(i + 1)) {
            i--;
        }
        
        // Шаг 20: Если такой индекс не найден - перестановок больше нет
        if (i < 0) {
            return false;
        }
        
        // Шаг 21: Находим наименьший элемент справа от i, который больше list[i]
        int j = list.size() - 1;
        while (list.get(j) <= list.get(i)) {
            j--;
        }
        
        // Шаг 22: Меняем местами элементы на позициях i и j
        Collections.swap(list, i, j);
        
        // Шаг 23: Переворачиваем последовательность справа от i
        Collections.reverse(list.subList(i + 1, list.size()));
        
        // Шаг 24: Возвращаем true - следующая перестановка сгенерирована
        return true;
    }
    
    // Шаг 25: Главный метод программы
    public static void main(String[] args) {
        // Шаг 26: Создаем матрицу смежности графа (расстояния между городами)
        int[][] graph = {
            {0, 10, 15, 20},    // Расстояния от города 0 к другим
            {10, 0, 35, 25},    // Расстояния от города 1 к другим
            {15, 35, 0, 30},    // Расстояния от города 2 к другим
            {20, 25, 30, 0}     // Расстояния от города 3 к другим
        };
        
        // Шаг 27: Вызываем функцию TSP и выводим результат
        System.out.println("Минимальный путь: " + tsp(graph, 0));
    }
}
