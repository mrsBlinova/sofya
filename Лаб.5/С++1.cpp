#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

// Функция для решения задачи коммивояжера (Traveling Salesman Problem)
int tsp(vector<vector<int>>& graph, int s) {
    // Шаг 1: Получаем количество вершин (городов) в графе
    int V = graph.size();
    
    // Шаг 2: Создаем вектор для хранения вершин, кроме стартовой
    vector<int> vertex;
    
    // Шаг 3: Заполняем вектор всеми городами, кроме стартового
    for(int i = 0; i < V; i++)
        if(i != s)
            vertex.push_back(i);
    
    // Шаг 4: Инициализируем минимальный путь максимально возможным значением
    int min_path = INT_MAX;
    
    // Шаг 5: Перебираем все возможные перестановки городов
    do {
        // Шаг 6: Инициализируем вес текущего пути
        int current_pathweight = 0;
        
        // Шаг 7: Начинаем со стартового города
        int j = s;
        
        // Шаг 8: Проходим по всем городам в текущей перестановке
        for(int i = 0; i < vertex.size(); i++) {
            // Шаг 9: Добавляем вес ребра от текущего города к следующему
            current_pathweight += graph[j][vertex[i]];
            
            // Шаг 10: Переходим к следующему городу
            j = vertex[i];
        }
        
        // Шаг 11: Добавляем вес возвращения в стартовый город
        current_pathweight += graph[j][s];
        
        // Шаг 12: Обновляем минимальный путь, если нашли лучшее решение
        min_path = min(min_path, current_pathweight);
        
    } while(next_permutation(vertex.begin(), vertex.end())); // Шаг 13: Генерируем следующую перестановку
    
    // Шаг 14: Возвращаем найденный минимальный путь
    return min_path;
}

int main() {
    // Шаг 15: Создаем матрицу смежности графа (расстояния между городами)
    vector<vector<int>> graph = {
        {0, 10, 15, 20},    // Расстояния от города 0 к другим
        {10, 0, 35, 25},    // Расстояния от города 1 к другим
        {15, 35, 0, 30},    // Расстояния от города 2 к другим
        {20, 25, 30, 0}     // Расстояния от города 3 к другим
    };
    
    // Шаг 16: Вызываем функцию TSP и выводим результат
    cout << "Минимальный путь: " << tsp(graph, 0) << endl;
    
    // Шаг 17: Завершаем программу
    return 0;
}
